var accessMongo = require( '../../../models/pull-report-data.js' );
var helper = require( '../../../models/helpers.js' );
var xss = require( '../../../models/security/xss-util.js' );
var event = require( 'events' );

/**
 * @class Set of functions around creating a report about static analysis vulnerability types. These types might include 
 * CrossSiteScripting.Reflected, CSRF, Validation.Required, etc. The idea behind these reports is to report on the number of findings,
 * valid vs. false_positives, and drill into the specific method/API of the vulnerability itself.
 * 
 * @author Matthew Saltzman
 * @since 8-19-2013 
 */
var vulnerabilityTypeReport = {
  /**
   * Function to generate the vulnerability type report for our static analysis process. 
   *  
   * @param {Object} request The request object
   * @param {Object} response The response object
   * @param {Object} collection The MongoDB collection containing the findings data
   * 
   * @throws An error if the conf parameter is not an Array of strings
   * @throws An error if the sev parameter is not an Array of strings
   */
  vulnerabilityTypeReport : function(request, response, collection) 
  {
    //grabbing the security and exceptions loggers
    var security = helper.getLoggers().security;
    var excptions = helper.getLoggers().exceptions;
    
    //Is each element in the array a valid long string 
    var confIsString = ( typeof request.query.conf == "string" );
    var sevIsString = ( typeof request.query.sev == "string" );
    
    //The vulnerability type, if it exists, triggers a drill-down report
    var vtype = request.query.vtype;
    
    //If the vtype parameter exists, and isn't a valid string, throw an error and redirect the user
    if( vtype && !xss.isValidLongString( vtype ) )
    {
      //add to the security log because the vtype parameter should always be a valid string 
      security.log( 'warn', "vtype parameter not a valid string, potential tampering", { 'user' : request.session.username, 
                                                                                         'vtype' : vtype } );
      //redirecting the user to / since the conf parameter is invalid
      response.redirect( '/?error[header]=invalid%20string%20found:%3A' + vtype + '&error[date]=' + new Date() );                                                                      
      //Throw an error so as to exit the function without completing
      throw new Error( "vtype parameter not a valid string" );         
    }
    
    //the set of confidence values we're looking for
    var conf;
    if( confIsString )
    {
      conf = request.query.conf.split( ',' );
    }
    //the set of severity values we're looking for
    var sev;
    if( sevIsString )
    {
      sev = request.query.sev.split( ',' );
    }
    
    //If conf exists (in other words, was a valid string before)
    if( conf )
    {    
      //Iterate through the list of confidence ratings
      for( confIter in conf )
      {
        //if any element in the array is not valid, set the value to false
        if( !xss.isValidLongString( conf[ confIter ] ) )
        {
          confIsString = false;
        }
      }
    }
    //otherwise, set confIsString to false
    else
    {
      confIsString = false;
    }
    
    //If sev exists (in other words, was a valid string before)
    if( sev )
    {
      //Iterate through the list of severity ratings
      for( sevIter in sev )
      {
        //if any element in the array is not valid, set the value to false
        if( !xss.isValidLongString( sev[ sevIter ] ) )
        {
          sevIsString = false;
        }
      }
    }
    //otherwise, set confIsString to false
    else
    {
      sevIsString = false;
    }
    
    //Trap any error where conf or sev is not an array, or any element in the array is not a string
    if( !( ( conf instanceof Array ) && confIsString ) )
    {
      //add to the security log because the conf parameter should always be an array without manual modification 
      security.log( 'warn', "conf parameter modified to not be an array", { 'user' : request.session.username, 
                                                                            'conf' : conf } );
      //redirecting the user to / since the conf parameter is invalid
      response.redirect( '/?error[header]=invalid value found for conf parameter: ' + conf + '&error[date]' + new Date() );                                                                      
      //Throw an error so as to exit the function without completing
      throw new Error( "conf parameter is not of type array" );                                                                            
    }
    
    if( !( ( sev instanceof Array ) && sevIsString ) )
    {
      //add to the security log because the sev parameter should always be an array without manual modification
      security.log( 'warn', "sev parameter modified to not be an array", { 'user' : request.session.username, 
                                                                            'sev' : sev } );
      //redirecting the user to / since the sev parameter is invalid                                                                            
      response.redirect( '/?error[header]=invalid value found for sev parameter: ' + sev + '&error[date]' + new Date() );
      //Throw an error so as to exit the function without completing                                                                      
      throw new Error( "sev parameter is not of type array" );                                                                            
    }
    
    //The minimum date we're looking for, as an ObjectID for easy comparison to existing issues, or null
    var minDate = helper.createObjectidTimestamp( new Date( parseInt( request.query.beginDate ) ) );
    //The maximum date we're looking for, as an ObjectID for easy comparison to existing issues, or null
    var maxDate = helper.createObjectidTimestamp( new Date( parseInt( request.query.endDate ) ) ); 
    
    //creating an event emitter, which functions similarly to a callback method
    var ee = new event.EventEmitter();
    
    ee.once( "results from complex group query found", function( results )
    {
      exports.renderVulnerabilityReport( request, response, results );
    } );

    //matches only findings that are have a confidence or severity rating of the types that were passed in
    var match = { $match : { "conf" : { $in : conf }, "sev" : { $in :  sev } } };
    
    
    if( minDate != null )
    {
      match.$match._id = { $gte : minDate };
    }
    
    if( maxDate != null )
    { 
      if( match.$match._id != null )
      {
        match.$match._id.$lte = maxDate;  
      }
      else
      {
        match.$match._id = { $lte : maxDate };
      }
    }
    
    //if vtype exists, then also match on it   
    if( vtype )
    {
      match.$match[ "vtype" ] = vtype;
    }
    
    //Group that de-duplicates the findings for us
    var group = { 
      $group : { 
        //_id provides a unique identifier for a specific issue (project name excluded for now, but can easily be included)
        _id : { 
          vtype : "$vtype", 
          ln : "$ln", 
          method : "$method", 
          file : "$file_path", 
          application_name : "$application_name" 
        }, 
        //create a (hopefully single element) array of review statuses
        status : { 
          $push : "$review.status" 
        } 
      } 
    };
    //Generates the actual report of unique vulnerability types by status, count one for each element being grouped together
    var group2;
    //if we specified a specific vtype, then group by the method(finding API) within that vtype
    if( vtype )
    {
      group2 = { $group : { _id : { method : "$_id.method", status : "$status" }, count : { $sum : 1 } } };
    }
    //if no vtype is specified, find each vulnerability type
    else
    {
      group2 = { $group : { _id : { vtype : "$_id.vtype", status : "$status" }, count : { $sum : 1 } } };
    }
    //Arrange the results in order of vulnerability type from a - z
    var sort = { $sort : { "_id.vtype" : 1 } };
    
    //Create the pipeline to run the aggregation query with
    var pipeline = [ match, group, group2, sort ];
    //Run the aggregation query
    accessMongo.complexAggregation( collection, pipeline, ee );
  },
  
  /**
   * Function that creates and renders the vulnerability report requested by the previous function.
   *  
   * @param {Object} request The request object
   * @param {Object} response The response object
   * @param {Object} results The results of the aggregation query that created the report
   */
  renderVulnerabilityReport : function( request, response, results )
  {
    
    var data = [];
    var title = "";
    
    //Assess which type of report this is
    if( results[ 0 ]._id.vtype )
    {
      title = "Vulnerability Type";
    }
    else if( results[ 0 ]._id.method )
    {
      title = "Vulnerability Method";
    }
        
    for( rowIter in results )
    {
      //select the category name based on the title of the report
      var catName;
      //get the status of this entry
      var status;
      
      if( title == "Vulnerability Type" )
      {
        catName = results[ rowIter ]._id.vtype;
      }
      else if( title == "Vulnerability Method" )
      {
        catName = results[ rowIter ]._id.method;
      }
      var type = null;
      
      //determine if this is a new category or not
      for( dataIter in data )
      {
        if( data[ dataIter ].categoryName == catName )
        {
          type = dataIter;
          break;
        }
      }
      
      //if it isn't a new category
      if( !type )
      {
        //create the category 
        var newData = {
          categoryName : catName,
          unreviewed : 0,
          valid : 0,
          fp : 0,
          total : 0
        };
        
        //assign the newType identifyer to the new position about to be created
        type = data.length;
        
        //push this entry into the data array
        data.push( newData );
      }
      
      //If the status is not defined yet (meaning unreviewed)
      if( results[ rowIter ]._id.status.length == 0 )
      {
        status = "unreviewed";
      }
      //If the status is defined (meaning reviewed)
      else
      {
        status = results[ rowIter ]._id.status[ 0 ];
      }
      
      //Determine which series to append to
      switch( status )
      {
        //The unreviewed set
        case "unreviewed" : 
          //set this element in the unreviewed set 
          data[ type ].unreviewed += results[ rowIter ].count;
          break;
        //the valid issues set
        case "valid" :  
          data[ type ].valid += results[ rowIter ].count;
          break;
        //the false positive issues set
        case "false_positive" :
          data[ type ].fp += results[ rowIter ].count;
          break;
      }
      
      //also update the total entry with this value
      data[ type ].total += results[ rowIter ].count;
    }
    
    //data object for displaying the data to users
    var reportData = {};
    
    //build the data object to be passed to the jade template
    reportData[ "categoryField" ] = 'categoryName';
    reportData[ "valueFields" ] = [ 
      { id : 'unreviewed', label : "Unreviewed" }, 
      { id : 'valid', label : "Valid Issues" }, 
      { id : 'fp', label : "False Positives" }, 
      { id : 'total', label : "Total Findings" } 
    ];
    reportData[ "data" ] = data;
    reportData[ "reportTitle" ] = title + " Report: Quality Results";
    reportData[ "yTitle" ] = "Number of Findings";
    //Determines the height of the report, in pixels
    reportData[ "pixels" ] = 100 + ( 50 * data.length );
    
    //display the report to the users
    response.render( "bar-graph-with-selectors.jade", reportData );
  }
};

exports.vulnerabilityTypeReport = vulnerabilityTypeReport.vulnerabilityTypeReport;
exports.renderVulnerabilityReport = vulnerabilityTypeReport.renderVulnerabilityReport;